/***********************************************************************************/
/*  Copyright 2014 WSL Institute for Snow and Avalanche Research    SLF-DAVOS      */
/***********************************************************************************/
/* This file is part of Snowpack.
    MeteoIO is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MeteoIO is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with MeteoIO.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "CaaMLIO.h"
//#include <meteoio/meteolaws/Atmosphere.h>

#include <sstream>

#include <libxml/parserInternals.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
#if !defined(LIBXML_XPATH_ENABLED)
#error Please enable XPATH in your version of libxml!
#endif
#if !defined(LIBXML_SAX1_ENABLED)
	#error Please enable SAX1 in your version of libxml!
#endif
#if !defined(LIBXML_TREE_ENABLED)
	#error Please enable TREE in your version of libxml!
#endif

using namespace std;
using namespace mio;

/**
 * @page caaml CAAML
 * @section caaml_format Format
 * This plugin reads the CAAML files as generated by <A HREF="http://caaml.org/">CAAML V5.0</A>'s <A HREF="http://caaml.org/Schemas/V5.0/Profiles/SnowProfileIACS">???</A>.
 *
 * @section caaml_units Units
 * The units are assumed to be the following:
 * - temperatures in K
 * -  in
 * -  in
 * -  in
 *
 * @section camml_keywords Keywords
 * This plugin uses the following keywords:
 * - COORDSYS:  input coordinate system (see Coords) specified in the [Input] section
 * - SNOW:     specify COSMOCAAML for [Input] section
 * - SNOWPATH: string containing the path to the xml files to be read, specified in the [Input] section
 * - SNOWFILE: specify the xml file to read the data from (optional)
 * - SNOW_PREFIX: file name prefix appearing before the date (optional)
 * - SNOW_EXT: file extension (default: ".xml", give "none" to get an empty string)
 * - STATION#: ID of the station to read
 * - IMIS_STATIONS: if set to true, all station IDs provided above will be stripped of their number (to match MeteoCH naming scheme)
 * - USE_MODEL_LOC: if set to false, the true station location (lat, lon, altitude) is used. Otherwise, it uses the model location (default)
 * - XML_ENCODING: force the input file encoding, overriding the file's own encoding declaration (optional, see \ref caaml_encoding "XML encoding" below)
 *
 * If no SNOWFILE is provided, all "*.caaml" files in the SNOWPATH directory will be read, if they match the SNOW_PREFIX and SNOW_EXT.
 * They <i>must</i> contain the date of the first data formatted as ISO8601 numerical UTC date in their file name. For example, a file containing simulated
 * meteorological fields from 2014-03-03T12:00 until 2014-03-05T00:00 could be named such as "cosmo_201403031200.xml"
 * If some numbers appear <i>before</i> the numerical date, they must be provided as part of SNOW_PREFIX so the plugin can
 * properly extract the date (for MeteoSwiss, this must be set to "VNMH49").
 *
 * Example:
 * @code
 * [Input]
 * COORDSYS	= CH1903
 * SNOW	= CAAML
 * SNOWPATH	= ./input/snowCAAMLdata
 * SNOWFILE	= 5WJ_20120229.caaml
 * @endcode
 *
 * @subsection caaml_encoding XML encoding
 * Each XML document should specify its encoding. However this information might sometimes be missing or even worse, be false. This makes the XML document non-compliant.
 * Normally, CAAML reads the file encoding in the file itself. If this does not work (one of the two cases given above), it is possible to force the
 * encoding of the input file by using the "XML_ENCODING" option. This option takes one of the following values
 * ("LE" stands for "Little Endian" and "BE" for "Big Endian"):
 *  - for UTF/UCS: UTF-8, UTF-16-LE, UTF-16-BE, UCS-4-LE, UCS-4-BE, UCS-4-2143, UCS-4-3412, UCS-2, EBCDIC
 *  - for ISO-8859: ISO-8859-1, ISO-8859-2, ISO-8859-3, ISO-8859-4, ISO-8859-5, ISO-8859-6, ISO-8859-7, ISO-8859-8, ISO-8859-9
 *  - for Japanses: ISO-2022-JP, SHIFT-JIS, EUC-JP
 *  - for ascii: ASCII
 *
 */

const xmlChar* CaaMLIO::xml_namespace = (const xmlChar *)"http://caaml.org/Schemas/V5.0/Profiles/SnowProfileIACS";
const xmlChar* CaaMLIO::xml_namespace_abrev = (const xmlChar*)"caaml";
const std::string CaaMLIO::StationMetaData_xpath = "/caaml:SnowProfile/caaml:locRef/caaml:ObsPoint";
const std::string CaaMLIO::SnowData_xpath = "/caaml:SnowProfile/caaml:snowProfileResultsOf/caaml:SnowProfileMeasurements";

CaaMLIO::CaaMLIO(const SnowpackConfig& cfg, const RunInfo& run_info)
           : info(run_info),
             i_snowpath(), sw_mode(), o_snowpath(), experiment(),
             useSoilLayers(false), perp_to_slope(false), in_tz(),
             snow_prefix(), snow_ext(".caaml"), caaml_nodata(-999.),
             in_doc(NULL), in_xpathCtx(NULL), in_encoding(XML_CHAR_ENCODING_NONE)
{
	init(cfg);
}

void CaaMLIO::init(const SnowpackConfig& cfg)
{
	std::string tmpstr;

	LIBXML_TEST_VERSION //check lib versions and call xmlInitParser()

	cfg.getValue("SW_MODE", "Snowpack", sw_mode);
	cfg.getValue("SNP_SOIL", "Snowpack", useSoilLayers);
	cfg.getValue("PERP_TO_SLOPE", "SnowpackAdvanced", perp_to_slope);
	cfg.getValue("TIME_ZONE", "Input", in_tz);

	cfg.getValue("SNOW_EXT", "INPUT", snow_ext, IOUtils::nothrow);
	//	if( IOUtils::strToUpper(snow_ext)=="NONE" ) snow_ext="";
	cfg.getValue("METEOPATH", "Input", tmpstr, IOUtils::nothrow);
	cfg.getValue("SNOWPATH", "Input", i_snowpath, IOUtils::nothrow);
	if (i_snowpath.empty())
		i_snowpath = tmpstr;

	cfg.getValue("EXPERIMENT", "Output", experiment);
	cfg.getValue("METEOPATH", "Output", tmpstr, IOUtils::nothrow);
	cfg.getValue("SNOWPATH", "Output", o_snowpath, IOUtils::nothrow);
	if (o_snowpath.empty())
		o_snowpath = tmpstr;

	//input encoding forcing, inherited from CosmoXMLIO
	tmpstr.clear();
	cfg.getValue("XML_ENCODING", "INPUT", tmpstr, IOUtils::nothrow);
	if(!tmpstr.empty()) {
		if(tmpstr=="UTF-8") in_encoding=XML_CHAR_ENCODING_UTF8;
		else if(tmpstr=="UTF-16-LE") in_encoding=XML_CHAR_ENCODING_UTF16LE;
		else if(tmpstr=="UTF-16-BE") in_encoding=XML_CHAR_ENCODING_UTF16BE;
		else if(tmpstr=="UCS-4-LE") in_encoding=XML_CHAR_ENCODING_UCS4LE;
		else if(tmpstr=="UCS-4-BE") in_encoding=XML_CHAR_ENCODING_UCS4BE;
		else if(tmpstr=="EBCDIC") in_encoding=XML_CHAR_ENCODING_EBCDIC;
		else if(tmpstr=="UCS-4-2143") in_encoding=XML_CHAR_ENCODING_UCS4_2143;
		else if(tmpstr=="UCS-4-3412") in_encoding=XML_CHAR_ENCODING_UCS4_3412;
		else if(tmpstr=="UCS-2") in_encoding=XML_CHAR_ENCODING_UCS2;
		else if(tmpstr=="ISO-8859-1") in_encoding=XML_CHAR_ENCODING_8859_1;
		else if(tmpstr=="ISO-8859-2") in_encoding=XML_CHAR_ENCODING_8859_2;
		else if(tmpstr=="ISO-8859-3") in_encoding=XML_CHAR_ENCODING_8859_3;
		else if(tmpstr=="ISO-8859-4") in_encoding=XML_CHAR_ENCODING_8859_4;
		else if(tmpstr=="ISO-8859-5") in_encoding=XML_CHAR_ENCODING_8859_5;
		else if(tmpstr=="ISO-8859-6") in_encoding=XML_CHAR_ENCODING_8859_6;
		else if(tmpstr=="ISO-8859-7") in_encoding=XML_CHAR_ENCODING_8859_7;
		else if(tmpstr=="ISO-8859-8") in_encoding=XML_CHAR_ENCODING_8859_8;
		else if(tmpstr=="ISO-8859-9") in_encoding=XML_CHAR_ENCODING_8859_9;
		else if(tmpstr=="ISO-2022-JP") in_encoding=XML_CHAR_ENCODING_2022_JP;
		else if(tmpstr=="SHIFT-JIS") in_encoding=XML_CHAR_ENCODING_SHIFT_JIS;
		else if(tmpstr=="EUC-JP") in_encoding=XML_CHAR_ENCODING_EUC_JP;
		else if(tmpstr=="ASCII") in_encoding=XML_CHAR_ENCODING_ASCII;
		else
			throw InvalidArgumentException("Encoding \""+tmpstr+"\" is not supported!", AT);
	}
}

CaaMLIO& CaaMLIO::operator=(const CaaMLIO& source) {
	if(this != &source) {
// 		cache_snow_files = source.cache_snow_files;
// 		xml_stations_id = source.xml_stations_id;
// 		input_id = source.input_id;
		caaml_nodata = source.caaml_nodata;
		in_doc = NULL;
		in_xpathCtx = NULL;
	}
	return *this;
}

CaaMLIO::~CaaMLIO() throw()
{
	closeIn_CAAML();
}

void CaaMLIO::openIn_CAAML(const std::string& in_snowfile)
{
//	if(in_doc!=NULL) return; //the file has already been read
	xmlInitParser();
	xmlKeepBlanksDefault(0);

	if(in_encoding==XML_CHAR_ENCODING_NONE) {
		in_doc = xmlParseFile(in_snowfile.c_str());
	} else {
		xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt( in_snowfile.c_str() );
		xmlSwitchEncoding( ctxt, in_encoding);
		xmlParseDocument( ctxt);
		in_doc = ctxt->myDoc;
	}

//	in_doc = xmlReadFile(in_snowfile.c_str(), NULL, 0);
// 	if (in_doc == NULL) {
// 		throw FileNotFoundException("Could not open/parse file \""+in_snowfile+"\"", AT);
// 	}

	if(in_xpathCtx != NULL) xmlXPathFreeContext(in_xpathCtx); //free variable if this was not freed before
	in_xpathCtx = xmlXPathNewContext(in_doc);
	if(in_xpathCtx == NULL) {
		closeIn_CAAML();
		throw IOException("Unable to create new XPath context", AT);
	}

	if(xmlXPathRegisterNs(in_xpathCtx, xml_namespace_abrev, xml_namespace) != 0) {
		throw IOException("Unable to register namespace with prefix", AT);
	}
}

void CaaMLIO::closeIn_CAAML() throw()
{
	if(in_xpathCtx!=NULL) {
		xmlXPathFreeContext(in_xpathCtx);
		in_xpathCtx = NULL;
	}
	if(in_doc!=NULL) {
		xmlFreeDoc(in_doc);
		in_doc = NULL;
	}
	xmlCleanupParser();
}

// bool CaaMLIO::parseStationData(const std::string& station_id, const xmlXPathContextPtr& xpathCtx, StationData &sd)
// {
	//match something like "/ns:valueinformation/ns:values-tables/ns:data/ns:row/ns:col[@id='station_abbreviation' and text()='ATT']/.."
	//the namespace "ns" has been previously defined
//	const std::string xpath_id = (imis_stations)? station_id.substr(0, station_id.find_first_of("0123456789")) : station_id;
// 	const std::string xpath = StationData_xpath+"[@id='station_abbreviation' and text()='"+xpath_id+"']/.."; //and we take the parent node <row>
// 	const std::string xpath = SnowData_xpath+"/SnowProfileMeasurements/profileDepth";

// 	xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar*)xpath.c_str(), xpathCtx);
// 	if(xpathObj == NULL) return false;

	//check the number of matches
// 	const xmlNodeSetPtr &metadata = xpathObj->nodesetval;
// 	const int nr_metadata = (metadata) ? metadata->nodeNr : 0;
// 	if(nr_metadata==0)
// 		throw NoAvailableDataException("No metadata found for station \""+station_id+"\"", AT);
// 	if(nr_metadata>1)
// 		throw InvalidFormatException("Multiple definition of metadata for station \""+station_id+"\"", AT);

// 	xmlNode *cur_node = metadata->nodeTab[0];
// 	printf("\n%s\n", xmlGetProp(cur_node, (const xmlChar *)"uom"));
// 	printf("%s\n", (const xmlChar*) (cur_node->children->content));
	// 	xmlFree(att);


	//collect all the data fields
// 	std::string xml_id;
// 	double altitude = IOUtils::nodata, latitude = IOUtils::nodata, longitude = IOUtils::nodata;
// 	//start from the first child until the last one
// 	for (xmlNode *cur_node = metadata->nodeTab[0]->children; cur_node; cur_node = cur_node->next) {
// 		if (cur_node->type == XML_ELEMENT_NODE) {
// 			xmlChar *att = xmlGetProp(cur_node, xml_attribute);
// 			const std::string field( (const char*)(att) );
// 			xmlFree(att);
// 
// 			if (cur_node->children->type == XML_TEXT_NODE) {
// 				const std::string value( (const char*)(cur_node->children->content) );
// 
// 				if(field=="identifier") xml_id = value;
// 				//else if(field=="station_abbreviation") sd.stationID = value;
// 				else if(field=="station_name") sd.stationName = value;
// 				else if(field=="missing_value_code") IOUtils::convertString(plugin_nodata, value);
// 
// 				if(use_model_loc) {
// 					if(field=="station_height") IOUtils::convertString(altitude, value);
// 					else if(field=="station_latitude") IOUtils::convertString(latitude, value);
// 					else if(field=="station_longitude") IOUtils::convertString(longitude, value);
// 				} else {
// 					if(field=="model_station_height") IOUtils::convertString(altitude, value);
// 					else if(field=="model_station_latitude") IOUtils::convertString(latitude, value);
// 					else if(field=="model_station_longitude") IOUtils::convertString(longitude, value);
// 				}
// 			}
// 		}
// 	}
// 
// 	sd.stationID = station_id;
// 
// 	if(latitude==IOUtils::nodata || longitude==IOUtils::nodata || altitude==IOUtils::nodata)
// 		throw NoAvailableDataException("Some station location information is missing for station \""+station_id+"\"", AT);
// 	sd.position.setProj(coordin, coordinparam);
// 	sd.position.setLatLon(latitude, longitude, altitude);
// 
// 	if(xml_id.empty())
// 		throw NoAvailableDataException("CAAML station id missing for station \""+station_id+"\"", AT);
// 	xml_stations_id[station_id] = xml_id;

// 	xmlXPathFreeObject(xpathObj);
// 	return true;
// }

// CaaMLIO::SnowReadStatus CaaMLIO::parseMeteoDataPoint(const Date& dateStart, const Date& dateEnd, const xmlNodePtr &element, MeteoData &md) const
// //private CosmoXMLIO
// {
// 	double iswr_dir = IOUtils::nodata, iswr_diff = IOUtils::nodata;
// 
// 	//collect all the data fields
// 	for (xmlNode *cur_node = element; cur_node; cur_node = cur_node->next) {
// 		if (cur_node->type == XML_ELEMENT_NODE) {
// 			xmlChar *att = xmlGetProp(cur_node, xml_attribute);
// 			const std::string field( (const char*)(att) );
// 			xmlFree(att);
// 
// 			if (cur_node->children->type == XML_TEXT_NODE) {
// 				const std::string value( (const char*)(cur_node->children->content) );
// 				if(field=="reference_ts") {
// 					IOUtils::convertString(md.date, value, in_tz);
// 					if(md.date<dateStart) return read_continue;
// 					if(md.date>dateEnd) return read_stop;
// 				} else {
// 					double tmp;
// 					IOUtils::convertString(tmp, value);
// 					tmp = IOUtils::standardizeNodata(tmp, plugin_nodata);
// 
// 					//for now, we hard-code the fields mapping
// 					if(field=="108005") md(MeteoData::TA) = tmp;
// 					else if(field=="108014") md(MeteoData::RH) = tmp/100.;
// 					else if(field=="108015") md(MeteoData::VW) = tmp;
// 					else if(field=="108017") md(MeteoData::DW) = tmp;
// 					else if(field=="108018") md(MeteoData::VW_MAX) = tmp;
// 					else if(field=="108023") md(MeteoData::HNW) = tmp;
// 					else if(field=="108060") md(MeteoData::HS) = tmp/100.;
// 					else if(field=="108062") md(MeteoData::TSS) = tmp;
// 					else if(field=="108064") iswr_diff = tmp;
// 					else if(field=="108065") iswr_dir = tmp;
// 					else if(field=="108066") md(MeteoData::RSWR) = tmp;
// 					else if(field=="108067") md(MeteoData::ILWR) = tmp; //108068=olwr
// 				}
// 			}
// 		}
// 	}
// 
// 	if(iswr_diff!=IOUtils::nodata && iswr_dir!=IOUtils::nodata)
// 		md(MeteoData::ISWR) = iswr_diff+iswr_dir;
// 
// 	//because of the Kalman filter applied on VW, sometimes VW_MAX<VW
// 	if(md(MeteoData::VW)!=IOUtils::nodata && md(MeteoData::VW_MAX)!=IOUtils::nodata && md(MeteoData::VW_MAX)<md(MeteoData::VW))
// 		md(MeteoData::VW_MAX) = md(MeteoData::VW);
// 
// 	return read_ok;
// }
// 
// size_t CaaMLIO::getFileIdx(const Date& start_date) const
// //private CosmoXMLIO
// {
// 	if(cache_snow_files.empty())
// 		throw InvalidArgumentException("No input files found or configured!", AT);
// 
// 	//find which file we should open
// 	if(cache_snow_files.size()==1) {
// 		return 0;
// 	} else {
// 		for(size_t idx=1; idx<cache_snow_files.size(); idx++) {
// 			if(start_date>=cache_snow_files[idx-1].first && start_date<cache_snow_files[idx].first) {
// 				return idx--;
// 			}
// 		}
// 
// 		//not found, we take the closest timestamp we have
// 		if(start_date<cache_snow_files.front().first)
// 			return 0;
// 		else
// 			return cache_snow_files.size()-1;
// 	}
// }
// 
// void CaaMLIO::readStationData(const Date& station_date, std::vector<StationData>& vecStation)
// {
// 	vecStation.clear();
// 
// 	const std::string snowfile( cache_snow_files[ getFileIdx(station_date) ].second );
// 	openIn_CAAML(snowfile);
// 
// 	//read all the stations' metadata
// 	for(size_t ii=0; ii<input_id.size(); ii++) {
// 		StationData sd;
// 		if(!parseStationData(input_id[ii], in_xpathCtx, sd)) {
// 			closeIn_CAAML();
// 			throw IOException("Unable to evaluate xpath expression for station \""+input_id[ii]+"\"", AT);
// 		}
// 		vecStation.push_back(sd);
// 	}
// 
// 	closeIn_CAAML();
// }

// bool CaaMLIO::parseCaamlData(const Date& dateStart, const Date& dateEnd, const std::string& station_id, const StationData& sd, const xmlXPathContextPtr& xpathCtx, std::vector<MeteoData> &vecMeteo) const
// {
// 	const std::string xpath = SnowData_xpath+"[@id='identifier' and text()='"+station_id+"']";
// 
// 	xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar*)xpath.c_str(), xpathCtx);
// 	if(xpathObj == NULL) return false;
// 
// 	//check the number of matches
// 	const xmlNodeSetPtr &data = xpathObj->nodesetval;
// 	const int nr_data = (data) ? data->nodeNr : 0;
// 	if(nr_data==0)
// 		throw NoAvailableDataException("No data found for station \""+station_id+"\"", AT);
// 
// 	//loop over all data for this station_id
// 	for(int ii=0; ii<nr_data; ii++) {
// 		MeteoData md( Date(), sd);
// 
// 		const MeteoReadStatus status = parseMeteoDataPoint(dateStart, dateEnd, data->nodeTab[ii], md);
// 		if(status==read_stop) break;
// 		if(status==read_ok) vecMeteo.push_back( md );
// 	}
// 
// 	xmlXPathFreeObject(xpathObj);
// 	return true;
// }

/**
 * @brief This routine checks if the specified snow cover data exists
 * @param i_snowfile file containing the initial state of the snowpack
 * @param stationID
 * @return true if the file exists
 */
bool CaaMLIO::snowCoverExists(const std::string& i_snowfile, const std::string& /*stationID*/) const
{
	string snofilename = getFilenamePrefix(i_snowfile, i_snowpath, false);

	if (snofilename.rfind(".caaml") == string::npos) {
		snofilename += ".caaml";
	}

	return IOUtils::fileExists(snofilename);
}

/**
 * @brief This routine reads the status of the snow cover at program start
 * @param i_snowfile file containing the initial state of the snowpack
 * @param stationID
 * @param SSdata
 * @param Zdata
 */
void CaaMLIO::readSnowCover(const std::string& i_snowfile, const std::string& stationID,
                            SN_SNOWSOIL_DATA& SSdata, ZwischenData& Zdata)
//public SnowpackIO
{
	string snofilename = getFilenamePrefix(i_snowfile, i_snowpath, false);
	string hazfilename(snofilename);

	if (snofilename.rfind(".caaml") == string::npos) {
		snofilename += ".caaml";
		hazfilename += ".haz";
	} else {
		hazfilename.replace(hazfilename.rfind(".caaml"), 6, ".haz");
	}

	const Date sno_date = Date();
	//TODO assign correct value as const Date sno_date = read_snosmet(snofilename, stationID, SSdata);
	read_snocaaml(snofilename, stationID, SSdata);
	/*if (IOUtils::fileExists(hazfilename)) {
		const Date haz_date = SmetIO::read_hazsmet(hazfilename, Zdata);
		if (haz_date != sno_date)
			throw IOException("Inconsistent ProfileDate in files: " + snofilename + " and " + hazfilename, AT);
	} else*/ {
		Zdata.reset();
	}

	throw IOException("Working on implementation!", AT);
}

// complete filename_prefix
std::string CaaMLIO::getFilenamePrefix(const std::string& fnam, const std::string& path, const bool addexp) const
{
	//TODO: read only once (in constructor)
	string filename_prefix = path + "/" + fnam;
	
	if (addexp && (experiment != "NO_EXP")) //NOTE usually, experiment == NO_EXP in operational mode
		filename_prefix += "_" + experiment;
	
	return filename_prefix;
}

bool CaaMLIO::read_snocaaml(const std::string& in_snowFilename, const std::string& stationID, SN_SNOWSOIL_DATA& SSdata)
//private, template copied from SmetIO
{
	// Read CAAML snow profile file, parse TODO reword: header and fill SSdata with values from the [DATA] section

	openIn_CAAML(in_snowFilename);

	//Read actual data
// 	const std::string xpath = SnowData_xpath;  
// 	const std::string xpath = SnowData_xpath+"/caaml:profileDepth";
	const std::string xpath = SnowData_xpath+"/caaml:stratProfile/caaml:Layer";

	xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression((const xmlChar*)xpath.c_str(), in_xpathCtx);
	if(xpathObj == NULL) {
		closeIn_CAAML();
		throw NoAvailableDataException("No data found !", AT);
		return false;
	}

	const xmlNodeSetPtr &data = xpathObj->nodesetval;
// 	const int nr_data = (data) ? data->nodeNr : 0;
// 	if(nr_data==0)
// 		throw NoAvailableDataException("No data found !", AT);


	cout << "nr_data = " << data->nodeNr << endl;
	xmlNode *cur_node = data->nodeTab[0];
// 	std::cout << xmlGetProp(cur_node, (const xmlChar *)"dir") << endl;
// 	cur_node = (data->nodeTab[0]);
	std::cout << xmlGetProp(cur_node, (const xmlChar *)"uom") << endl;
	std::cout << (const xmlChar*) (cur_node->children->content) << endl;
	
	// preliminary checks TODO reword
// 	if (SSdata.nLayers > 0)
// 		SSdata.Ldata.resize(SSdata.nLayers, LayerData());
// 
// 	if (vec_timestamp.size() != SSdata.nLayers)
// 		throw InvalidFormatException("Xdata: Layers expected != layers read in " + sno_reader.get_filename(), AT);
// 
// 	const size_t nr_of_fields = sno_reader.get_nr_of_fields();
// 	const size_t nr_of_solutes = (nr_of_fields - 18) / 4;
// 
// 	if (SnowStation::number_of_solutes != nr_of_solutes)
// 		throw InvalidFormatException("Mismatch in number_of_solutes and fields in " + sno_reader.get_filename(), AT);

	//copy data to respective variables in SSdata
// 	size_t current_index = 0;
// 	for (size_t ll=0; ll<SSdata.nLayers; ll++) {
// 		//firstly deal with date
// 		IOUtils::convertString(SSdata.Ldata[ll].depositionDate, vec_timestamp[ll], in_tz);
// 		SSdata.Ldata[ll].depositionDate.rnd(1.);
// 
// 		if (SSdata.Ldata[ll].depositionDate > SSdata.profileDate) {
// 			prn_msg(__FILE__, __LINE__, "err", Date(),
// 					"Layer %d from bottom is younger (%lf) than ProfileDate (%lf) !!!",
// 					ll+1, SSdata.Ldata[ll].depositionDate.getJulian(), SSdata.profileDate.getJulian());
// 					throw IOException("Cannot generate Xdata from file " + sno_reader.get_filename(), AT);
// 		}
// 
// 		//secondly with the actual data
// 		SSdata.Ldata[ll].hl = vec_data[current_index++];
// 		SSdata.Ldata[ll].tl = vec_data[current_index++];
// 		SSdata.Ldata[ll].phiIce = vec_data[current_index++];
// 		SSdata.Ldata[ll].phiWater = vec_data[current_index++];
// 		SSdata.Ldata[ll].phiVoids = vec_data[current_index++];
// 		SSdata.Ldata[ll].phiSoil = vec_data[current_index++];
// 
// 		if (SSdata.Ldata[ll].tl < 100.) {
// 			SSdata.Ldata[ll].tl = C_TO_K(SSdata.Ldata[ll].tl);
// 		}
// 		SSdata.Ldata[ll].SoilRho = vec_data[current_index++];
// 		SSdata.Ldata[ll].SoilK = vec_data[current_index++];
// 		SSdata.Ldata[ll].SoilC = vec_data[current_index++];
// 		SSdata.Ldata[ll].rg = vec_data[current_index++];
// 		SSdata.Ldata[ll].rb = vec_data[current_index++];
// 		SSdata.Ldata[ll].dd = vec_data[current_index++];
// 		SSdata.Ldata[ll].sp = vec_data[current_index++];
// 		SSdata.Ldata[ll].mk = static_cast<unsigned short int>(vec_data[current_index++]+.5); //int
// 		SSdata.Ldata[ll].hr = vec_data[current_index++];
// 		SSdata.Ldata[ll].ne = static_cast<unsigned int>(vec_data[current_index++]+.5); //int
// 
// 		if (SSdata.Ldata[ll].rg>0. && SSdata.Ldata[ll].rb >= SSdata.Ldata[ll].rg) {
// 			//HACK To avoid surprises in lwsn_ConcaveNeckRadius()
// 			SSdata.Ldata[ll].rb = Metamorphism::max_grain_bond_ratio * SSdata.Ldata[ll].rg;
// 			prn_msg(__FILE__, __LINE__, "wrn", Date(), "Layer %d from bottom: bond radius rb/rg larger than Metamorphism::max_grain_bond_ratio=%lf (rb=%lf mm, rg=%lf mm)! Reset to Metamorphism::max_grain_bond_ratio", ll+1, Metamorphism::max_grain_bond_ratio, SSdata.Ldata[ll].rb, SSdata.Ldata[ll].rg);
// 		}
// 
// 		SSdata.Ldata[ll].CDot = vec_data[current_index++];
// 		SSdata.Ldata[ll].metamo = vec_data[current_index++];
// 
// 		for (size_t ii=0; ii<SnowStation::number_of_solutes; ii++) {
// 			SSdata.Ldata[ll].cIce[ii] = vec_data[current_index++];
// 			SSdata.Ldata[ll].cWater[ii] = vec_data[current_index++];
// 			SSdata.Ldata[ll].cVoids[ii] = vec_data[current_index++];
// 			SSdata.Ldata[ll].cSoil[ii] = vec_data[current_index++];
// 		}
// 	} //for loop over layers
// 
// 	SSdata.nN = 1;
// 	SSdata.Height = 0.;
// 	for (size_t ll = 0; ll < SSdata.nLayers; ll++) {
// 		SSdata.nN    += SSdata.Ldata[ll].ne;
// 		SSdata.Height += SSdata.Ldata[ll].hl;
// 	}
    xmlXPathFreeObject(xpathObj);
	closeIn_CAAML();
	return true;
}

/**
 * @brief This routine writes the status of the snow cover at program termination and at specified backup times
 * @param date current
 * @param Xdata
 * @param SSdata
 * @param Zdata
 * @param forbackup dump Xdata on the go
 */
void CaaMLIO::writeSnowCover(const mio::Date& date, const SnowStation& Xdata,
                             const ZwischenData& Zdata, const bool& forbackup)
{
//public SnowpackIO
	string snofilename = ""; //getFilenamePrefix(Xdata.meta.getStationID().c_str(), o_snopath) + ".caaml";
	string hazfilename = ""; //getFilenamePrefix(Xdata.meta.getStationID().c_str(), o_snopath) + ".haz";

	if (forbackup) {
		stringstream ss;
		ss << (int)(date.getJulian() + 0.5);
		snofilename += ss.str();
		hazfilename += ss.str();
	}

	writeSnowFile(snofilename, date, Xdata, Zdata);
	SmetIO::writeHazFile(hazfilename, date, Xdata, Zdata);

	throw IOException("Working on implementation!", AT);
}

void CaaMLIO::writeSnowFile(const std::string& /*snofilename*/, const mio::Date& /*date*/, const SnowStation& /*Xdata*/,
                           const ZwischenData& /*Zdata*/) const
{
//public AsciiIO
	/*
	* This procedure creates a SMETWriter object, sets its header and copies all required
	* data and timestamps into vec_timestamp and vec_data (from Xdata).
	* The SMETWriter object finally writes out the SNO SMET file
	*/
// 	smet::SMETWriter sno_writer(snofilename);
	throw IOException("Working on implementation!", AT);
}

void CaaMLIO::writeTimeSeries(const SnowStation& /*Xdata*/, const SurfaceFluxes& /*Sdata*/, const CurrentMeteo& /*Mdata*/,
                              const ProcessDat& /*Hdata*/, const double /*wind_trans24*/)
{
	throw IOException("Nothing implemented here!", AT);
}

void CaaMLIO::writeProfile(const mio::Date& /*date*/, const SnowStation& /*Xdata*/)
{
	throw IOException("Working on implementation!", AT);
}

bool CaaMLIO::writeHazardData(const std::string& /*stationID*/, const std::vector<ProcessDat>& /*Hdata*/,
                             const std::vector<ProcessInd>& /*Hdata_ind*/, const size_t& /*num*/)
{
	throw IOException("Nothing implemented here!", AT);
}


